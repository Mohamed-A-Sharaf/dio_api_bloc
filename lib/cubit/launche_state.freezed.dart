// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'launche_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$LaunchesStateTearOff {
  const _$LaunchesStateTearOff();

  InitalState charactersInitial() {
    return const InitalState();
  }

  CharactersLoaded charactersLoaded(List<Launches> characters) {
    return CharactersLoaded(
      characters,
    );
  }

  CharacterLoaded characterLoaded(Launches launches) {
    return CharacterLoaded(
      launches,
    );
  }
}

/// @nodoc
const $LaunchesState = _$LaunchesStateTearOff();

/// @nodoc
mixin _$LaunchesState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() charactersInitial,
    required TResult Function(List<Launches> characters) charactersLoaded,
    required TResult Function(Launches launches) characterLoaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? charactersInitial,
    TResult Function(List<Launches> characters)? charactersLoaded,
    TResult Function(Launches launches)? characterLoaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? charactersInitial,
    TResult Function(List<Launches> characters)? charactersLoaded,
    TResult Function(Launches launches)? characterLoaded,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitalState value) charactersInitial,
    required TResult Function(CharactersLoaded value) charactersLoaded,
    required TResult Function(CharacterLoaded value) characterLoaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InitalState value)? charactersInitial,
    TResult Function(CharactersLoaded value)? charactersLoaded,
    TResult Function(CharacterLoaded value)? characterLoaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitalState value)? charactersInitial,
    TResult Function(CharactersLoaded value)? charactersLoaded,
    TResult Function(CharacterLoaded value)? characterLoaded,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LaunchesStateCopyWith<$Res> {
  factory $LaunchesStateCopyWith(
          LaunchesState value, $Res Function(LaunchesState) then) =
      _$LaunchesStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$LaunchesStateCopyWithImpl<$Res>
    implements $LaunchesStateCopyWith<$Res> {
  _$LaunchesStateCopyWithImpl(this._value, this._then);

  final LaunchesState _value;
  // ignore: unused_field
  final $Res Function(LaunchesState) _then;
}

/// @nodoc
abstract class $InitalStateCopyWith<$Res> {
  factory $InitalStateCopyWith(
          InitalState value, $Res Function(InitalState) then) =
      _$InitalStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$InitalStateCopyWithImpl<$Res> extends _$LaunchesStateCopyWithImpl<$Res>
    implements $InitalStateCopyWith<$Res> {
  _$InitalStateCopyWithImpl(
      InitalState _value, $Res Function(InitalState) _then)
      : super(_value, (v) => _then(v as InitalState));

  @override
  InitalState get _value => super._value as InitalState;
}

/// @nodoc

class _$InitalState with DiagnosticableTreeMixin implements InitalState {
  const _$InitalState();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LaunchesState.charactersInitial()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'LaunchesState.charactersInitial'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is InitalState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() charactersInitial,
    required TResult Function(List<Launches> characters) charactersLoaded,
    required TResult Function(Launches launches) characterLoaded,
  }) {
    return charactersInitial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? charactersInitial,
    TResult Function(List<Launches> characters)? charactersLoaded,
    TResult Function(Launches launches)? characterLoaded,
  }) {
    return charactersInitial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? charactersInitial,
    TResult Function(List<Launches> characters)? charactersLoaded,
    TResult Function(Launches launches)? characterLoaded,
    required TResult orElse(),
  }) {
    if (charactersInitial != null) {
      return charactersInitial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitalState value) charactersInitial,
    required TResult Function(CharactersLoaded value) charactersLoaded,
    required TResult Function(CharacterLoaded value) characterLoaded,
  }) {
    return charactersInitial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InitalState value)? charactersInitial,
    TResult Function(CharactersLoaded value)? charactersLoaded,
    TResult Function(CharacterLoaded value)? characterLoaded,
  }) {
    return charactersInitial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitalState value)? charactersInitial,
    TResult Function(CharactersLoaded value)? charactersLoaded,
    TResult Function(CharacterLoaded value)? characterLoaded,
    required TResult orElse(),
  }) {
    if (charactersInitial != null) {
      return charactersInitial(this);
    }
    return orElse();
  }
}

abstract class InitalState implements LaunchesState {
  const factory InitalState() = _$InitalState;
}

/// @nodoc
abstract class $CharactersLoadedCopyWith<$Res> {
  factory $CharactersLoadedCopyWith(
          CharactersLoaded value, $Res Function(CharactersLoaded) then) =
      _$CharactersLoadedCopyWithImpl<$Res>;
  $Res call({List<Launches> characters});
}

/// @nodoc
class _$CharactersLoadedCopyWithImpl<$Res>
    extends _$LaunchesStateCopyWithImpl<$Res>
    implements $CharactersLoadedCopyWith<$Res> {
  _$CharactersLoadedCopyWithImpl(
      CharactersLoaded _value, $Res Function(CharactersLoaded) _then)
      : super(_value, (v) => _then(v as CharactersLoaded));

  @override
  CharactersLoaded get _value => super._value as CharactersLoaded;

  @override
  $Res call({
    Object? characters = freezed,
  }) {
    return _then(CharactersLoaded(
      characters == freezed
          ? _value.characters
          : characters // ignore: cast_nullable_to_non_nullable
              as List<Launches>,
    ));
  }
}

/// @nodoc

class _$CharactersLoaded
    with DiagnosticableTreeMixin
    implements CharactersLoaded {
  const _$CharactersLoaded(this.characters);

  @override
  final List<Launches> characters;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LaunchesState.charactersLoaded(characters: $characters)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'LaunchesState.charactersLoaded'))
      ..add(DiagnosticsProperty('characters', characters));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CharactersLoaded &&
            const DeepCollectionEquality()
                .equals(other.characters, characters));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(characters));

  @JsonKey(ignore: true)
  @override
  $CharactersLoadedCopyWith<CharactersLoaded> get copyWith =>
      _$CharactersLoadedCopyWithImpl<CharactersLoaded>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() charactersInitial,
    required TResult Function(List<Launches> characters) charactersLoaded,
    required TResult Function(Launches launches) characterLoaded,
  }) {
    return charactersLoaded(characters);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? charactersInitial,
    TResult Function(List<Launches> characters)? charactersLoaded,
    TResult Function(Launches launches)? characterLoaded,
  }) {
    return charactersLoaded?.call(characters);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? charactersInitial,
    TResult Function(List<Launches> characters)? charactersLoaded,
    TResult Function(Launches launches)? characterLoaded,
    required TResult orElse(),
  }) {
    if (charactersLoaded != null) {
      return charactersLoaded(characters);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitalState value) charactersInitial,
    required TResult Function(CharactersLoaded value) charactersLoaded,
    required TResult Function(CharacterLoaded value) characterLoaded,
  }) {
    return charactersLoaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InitalState value)? charactersInitial,
    TResult Function(CharactersLoaded value)? charactersLoaded,
    TResult Function(CharacterLoaded value)? characterLoaded,
  }) {
    return charactersLoaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitalState value)? charactersInitial,
    TResult Function(CharactersLoaded value)? charactersLoaded,
    TResult Function(CharacterLoaded value)? characterLoaded,
    required TResult orElse(),
  }) {
    if (charactersLoaded != null) {
      return charactersLoaded(this);
    }
    return orElse();
  }
}

abstract class CharactersLoaded implements LaunchesState {
  const factory CharactersLoaded(List<Launches> characters) =
      _$CharactersLoaded;

  List<Launches> get characters;
  @JsonKey(ignore: true)
  $CharactersLoadedCopyWith<CharactersLoaded> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CharacterLoadedCopyWith<$Res> {
  factory $CharacterLoadedCopyWith(
          CharacterLoaded value, $Res Function(CharacterLoaded) then) =
      _$CharacterLoadedCopyWithImpl<$Res>;
  $Res call({Launches launches});
}

/// @nodoc
class _$CharacterLoadedCopyWithImpl<$Res>
    extends _$LaunchesStateCopyWithImpl<$Res>
    implements $CharacterLoadedCopyWith<$Res> {
  _$CharacterLoadedCopyWithImpl(
      CharacterLoaded _value, $Res Function(CharacterLoaded) _then)
      : super(_value, (v) => _then(v as CharacterLoaded));

  @override
  CharacterLoaded get _value => super._value as CharacterLoaded;

  @override
  $Res call({
    Object? launches = freezed,
  }) {
    return _then(CharacterLoaded(
      launches == freezed
          ? _value.launches
          : launches // ignore: cast_nullable_to_non_nullable
              as Launches,
    ));
  }
}

/// @nodoc

class _$CharacterLoaded
    with DiagnosticableTreeMixin
    implements CharacterLoaded {
  const _$CharacterLoaded(this.launches);

  @override
  final Launches launches;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'LaunchesState.characterLoaded(launches: $launches)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'LaunchesState.characterLoaded'))
      ..add(DiagnosticsProperty('launches', launches));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CharacterLoaded &&
            const DeepCollectionEquality().equals(other.launches, launches));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(launches));

  @JsonKey(ignore: true)
  @override
  $CharacterLoadedCopyWith<CharacterLoaded> get copyWith =>
      _$CharacterLoadedCopyWithImpl<CharacterLoaded>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() charactersInitial,
    required TResult Function(List<Launches> characters) charactersLoaded,
    required TResult Function(Launches launches) characterLoaded,
  }) {
    return characterLoaded(launches);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? charactersInitial,
    TResult Function(List<Launches> characters)? charactersLoaded,
    TResult Function(Launches launches)? characterLoaded,
  }) {
    return characterLoaded?.call(launches);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? charactersInitial,
    TResult Function(List<Launches> characters)? charactersLoaded,
    TResult Function(Launches launches)? characterLoaded,
    required TResult orElse(),
  }) {
    if (characterLoaded != null) {
      return characterLoaded(launches);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitalState value) charactersInitial,
    required TResult Function(CharactersLoaded value) charactersLoaded,
    required TResult Function(CharacterLoaded value) characterLoaded,
  }) {
    return characterLoaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InitalState value)? charactersInitial,
    TResult Function(CharactersLoaded value)? charactersLoaded,
    TResult Function(CharacterLoaded value)? characterLoaded,
  }) {
    return characterLoaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitalState value)? charactersInitial,
    TResult Function(CharactersLoaded value)? charactersLoaded,
    TResult Function(CharacterLoaded value)? characterLoaded,
    required TResult orElse(),
  }) {
    if (characterLoaded != null) {
      return characterLoaded(this);
    }
    return orElse();
  }
}

abstract class CharacterLoaded implements LaunchesState {
  const factory CharacterLoaded(Launches launches) = _$CharacterLoaded;

  Launches get launches;
  @JsonKey(ignore: true)
  $CharacterLoadedCopyWith<CharacterLoaded> get copyWith =>
      throw _privateConstructorUsedError;
}
